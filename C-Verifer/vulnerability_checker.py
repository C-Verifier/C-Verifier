# cverifier/vulnerability_checker.py
import sys
# We no longer need to import Z3 components here, as all Z3 logic is
# encapsulated within the predicate evaluators.
from .predicate_evaluators import (eval_AllowsAssumeRole, eval_ClassicFlowEnabled, eval_SpecifiedRoleInConfig,
                                   eval_HasWideTrustPolicy, eval_IsSubsetOfPermissions, eval_HasIntersection)
from .iam_utils import get_cleaned_policy_documents_from_role_data

# Policy Set Name Constants (used for clarity when calling evaluators)
PBASE_NAME = "Pbase"
PSESSION_NAME = "Psession"
PSENSITIVE_NAME = "Psensitive"

def check_vulnerabilities(config_data, policies, checks_to_run, target_pool_id=None, check_condition=False):
    """
    Checks for vulnerabilities using a high-performance, high-precision hybrid approach.

    This checker uses Python-level short-circuiting to avoid unnecessary computations,
    similar to the pure-Python version. However, for complex predicate evaluations 
    (IsSubsetOfPermissions, HasIntersection), it calls the robust predicate evaluators,
    which in turn use Z3 and FSM for maximum accuracy. This combines the speed of
    lazy evaluation with the precision of formal methods.
    """
    roles_data = config_data.get('roles', [])
    pools_data = config_data.get('cognito_identity_pools', [])

    if not roles_data or not pools_data:
        print("Error: Input data must contain 'roles' and 'cognito_identity_pools'.", file=sys.stderr)
        return []

    # Prepare data maps for O(1) lookups for better performance
    roles_map = {role['arn']: role for role in roles_data if isinstance(role, dict) and 'arn' in role}
    pools_map = {pool['id']: pool for pool in pools_data if isinstance(pool, dict) and 'id' in pool}

    # Determine which pools to analyze based on the target_pool_id argument
    pools_to_consider_str = list(pools_map.keys())
    if target_pool_id:
        if target_pool_id in pools_map:
            pools_to_consider_str = [target_pool_id]
        else:
            print(f"Warning: Target Cognito Pool ID '{target_pool_id}' not found in input data. No pools will be checked.", file=sys.stderr)
            return []
    
    detected_risks = []
    print("\n--- Checking vulnerabilities (High-performance, high-precision mode) ---")
    if check_condition:
        print("Note: Advanced 'Condition' block checking is ENABLED.")


    for current_pool_id_str in pools_to_consider_str:
        pool_data = pools_map.get(current_pool_id_str)
        pool_config = pool_data.get('config', {})

        print(f"\nChecking vulnerabilities for Cognito Pool: {current_pool_id_str}")

        for role_arn_str, role_entry in roles_map.items():
            role_trust_policy = role_entry.get('trust_policy_document')
            
            # This operation is done once per role and reused across checks
            cleaned_role_permission_docs = get_cleaned_policy_documents_from_role_data(
                role_entry.get('permission_policy_documents', [])
            )

            # --- Check 1: AllowsAssumeRole ∧ ¬IsSubsetOfPermissions(Pbase) ---
            if "check1" in checks_to_run:
                # Tier 2 check first (medium cost)
                if eval_AllowsAssumeRole(role_trust_policy, current_pool_id_str):
                    # Tier 3 check (high cost) only if necessary
                    if not eval_IsSubsetOfPermissions(
                        cleaned_role_permission_docs,
                        policies.get(PBASE_NAME, []),
                        check_condition=check_condition
                    ):
                        detected_risks.append({
                            "Risk Type": "Check 1: Role Trusting Pool with Permissions Beyond Pbase",
                            "Cognito Pool ID": current_pool_id_str,
                            "Involved Role ARN": role_arn_str,
                            "Details": "Role trusts this pool and its permissions are not a subset of Pbase."
                        })

            # --- Check 2: ClassicFlowEnabled ∧ AllowsAssumeRole ∧ ¬IsSubsetOfPermissions(Psession) ---
            if "check2" in checks_to_run:
                # Tier 1 and Tier 2 checks
                if eval_ClassicFlowEnabled(pool_config) and \
                   eval_AllowsAssumeRole(role_trust_policy, current_pool_id_str):
                    # Tier 3 check
                    if not eval_IsSubsetOfPermissions(
                        cleaned_role_permission_docs,
                        policies.get(PSESSION_NAME, []),
                        check_condition=check_condition
                    ):
                        detected_risks.append({
                            "Risk Type": "Check 2: Classic Flow & Role Trust with Permissions Beyond Psession",
                            "Cognito Pool ID": current_pool_id_str,
                            "Involved Role ARN": role_arn_str,
                            "Details": "Pool has Classic Flow, is trusted by the role, and role permissions exceed Psession."
                        })
            
            # --- Check 3: ClassicFlowEnabled ∧ HasWideTrustPolicy ---
            if "check3" in checks_to_run:
                # Tier 1 and Tier 2 (medium-high) checks
                if eval_ClassicFlowEnabled(pool_config) and \
                   eval_HasWideTrustPolicy(role_trust_policy, current_pool_id_str):
                    detected_risks.append({
                        "Risk Type": "Check 3: Classic Flow & Wide Trust Policy",
                        "Cognito Pool ID": current_pool_id_str,
                        "Involved Role ARN": role_arn_str,
                        "Details": "Pool has Classic Flow and the role has a trust policy allowing both authenticated and unauthenticated users."
                    })

            # --- Check 4: ClassicFlowEnabled ∧ AllowsAssumeRole ∧ ¬SpecifiedRoleInConfig ---
            if "check4" in checks_to_run:
                # Tier 1 and Tier 2 checks
                if eval_ClassicFlowEnabled(pool_config) and \
                   eval_AllowsAssumeRole(role_trust_policy, current_pool_id_str) and \
                   not eval_SpecifiedRoleInConfig(pool_config, role_arn_str):
                    detected_risks.append({
                        "Risk Type": "Check 4: Classic Flow & Trusted Role Not Specified in Config (Hanging Role)",
                        "Cognito Pool ID": current_pool_id_str,
                        "Involved Role ARN": role_arn_str,
                        "Details": "Pool has Classic Flow and is trusted by the role, but the role is not specified in the pool's configuration."
                    })

            # --- Check 5: ((ClassicFlowEnabled ∨ SpecifiedRoleInConfig) ∧ AllowsAssumeRole) ∧ HasIntersection(Psensitive) ---
            if "check5" in checks_to_run:
                # Combine Tier 1 and Tier 2 checks
                if (eval_ClassicFlowEnabled(pool_config) or eval_SpecifiedRoleInConfig(pool_config, role_arn_str)) and \
                   eval_AllowsAssumeRole(role_trust_policy, current_pool_id_str):
                    # Tier 3 check
                    if eval_HasIntersection(cleaned_role_permission_docs, policies.get(PSENSITIVE_NAME, [])):
                        detected_risks.append({
                            "Risk Type": "Check 5: Role Accessible via Classic Flow/Config with Sensitive Permissions",
                            "Cognito Pool ID": current_pool_id_str,
                            "Involved Role ARN": role_arn_str,
                            "Details": "An accessible role's permissions intersect with the sensitive permissions policy (Psensitive)."
                        })
                        
    return detected_risks